/*
 * Kable syntax parser
 *
 * In theory this minimal grammar will do all of my bidding,
 * I don’t need things like arrays, probably, as I could cast
 * say one,two into [one,two] if the argument requires it.
 * This also dispatches with unnamed args, we’ll create a
 * multi-line input to handle the inevitable long commands
 *
 * Maybe this will bite me in the ass. We’ll see!
 */
start
 = chain:chain {
  return {
    expression: chain
  }
 }

arg_list
 = first:argument rest:more_args* {
  var list = [first].concat(rest);
  var args = {};
  list.forEach(function (arg) {
   args[arg.name] = arg.value;
  })
  return args;
 }

more_args
 = space? arg:argument {return arg;}

argument
 = name:name '=' value:arg_type {
  return {
   name: name,
   value: value
  }
 }

eponymous_arg
 = '=' val:arg_type { return val; }

arg_type
 = '(' chain:chain ')' { return chain; }
 / literal

name // Functions and arguments can not start with a number
 = (first:[a-zA-Z]+ rest:[a-zA-Z0-9_-]* ) { return first.join('') + rest.join('') }

function "function"
 = name:name eponymous_arg:eponymous_arg? space? arg_list:arg_list? {
  var args = arg_list || {};
  if (eponymous_arg) args[name] = eponymous_arg;

  return {
   type: 'function',
   function: name,
   arguments: args
  }
 }

more_functions
 = space? '|' space? func:function {return func}

chain
 = func:function rest:more_functions* space? {return {type: 'chain', chain: [func].concat(rest)}}


 /* ----- Core types ----- */

literal "literal"
  =  '"' chars:dq_char* '"' { return chars.join(''); } // double quoted string
  / "'" chars:sq_char* "'" { return chars.join(''); } // single quoted string
  / 'true'  { return true; } // unquoted literals from here down
  / 'false' { return false; }
  / 'null'  { return null; }
  / string:[^\|()"'=\ \t]+ { // this also matches numbers via Number()
   var result = string.join('');
   // Sort of hacky, but PEG doesn't have backtracking so
   // a number rule is hard to read, and performs worse
   if (isNaN(Number(result))) return result;
   return Number(result)
  }

dq_char
  = "\\" sequence:('"' / "\\") { return sequence; }
  / [^"] // everything except "

sq_char
  = "\\" sequence:("'" / "\\") { return sequence; }
  / [^'] // everything except '

space
 = [\ \t]+