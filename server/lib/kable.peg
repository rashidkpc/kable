/*
 * Kable syntax parser
 *
 * In theory this minimal grammar will do all of my bidding,
 * I don’t need things like arrays, probably, as I could cast
 * say one,two into [one,two] if the argument requires it.
 * Maybe this will bite me in the ass. We’ll see!
 */

start
 = chain

chain
 = first:function rest:function* {
  return {
   type: 'chain',
   chain: [first].concat(rest)
  }
 }

 /* ----- Functions ----- */

function "function"
 = '.' + name:function_name arg_list:arg_list? {
  return {
    type: 'function',
    function: name,
    arguments: arg_list || []
  }
 }

function_name
 = (name:[a-zA-Z0-9_-]+ ) {
  return name.join('')
 }

 /* ----- Arguments ----- */

argument
 = name:function_name space? '=' space? value:arg_type {
  return {
   type: 'namedArg',
   name: name,
   value: value,
  }
 }
 / arg_type

arg_type
 = chain
 / literal

arg_list
 = '(' space? first:argument* rest:more_args* space? ')'{
  return first.concat(rest);
 }

more_args
 = space? ',' space? arg:argument {return arg;}

 /* ----- Core types ----- */

literal "literal"
  = '"' chars:dq_char* '"' { return chars.join(''); } // double quoted string
  / "'" chars:sq_char* "'" { return chars.join(''); } // single quoted string
  / 'true'  { return true; } // unquoted literals from here down
  / 'false' { return false; }
  / 'null'  { return null; }
  / string:[^()"',=\ \t]+ { // this also matches numbers via Number()
   var result = string.join('');
   // Sort of hacky, but PEG doesn't have backtracking so
   // a number rule is hard to read, and performs worse
   if (isNaN(Number(result))) return result;
   return Number(result)
  }

space
 = [\ \t]+

dq_char
  = "\\" sequence:('"' / "\\") { return sequence; }
  / [^"] // everything except "

sq_char
  = "\\" sequence:("'" / "\\") { return sequence; }
  / [^'] // everything except '
